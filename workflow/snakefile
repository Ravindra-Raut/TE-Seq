################### NEW SNAKE
import os
import pandas as pd
import csv
from pathlib import Path
from pandas.core.common import flatten

configfile: "conf/config.yaml"

final_input = []


for pipeline in config["pipelines_to_deploy"]:
    if pipeline == "aref":
        module aref:
            snakefile: "aref/snakefile"
            config: config["aref"]
        if config["aref"]["symlink_aref"]["response"] == "yes":
            use rule sym_link from aref as aref_*
            final_input.append("aref.symlinked.outfile")
        else:
            if config["aref"]["symlink_aref_contents"]["response"] == "yes":
                final_input.append("aref_contents.symlinked.outfile")
            if config["aref"]["update_ref_with_tldr"]["response"] == "yes":
                if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes":
                    use rule * from aref exclude tldr_aggregate_multiple_samples,get_repeatmasker_raw as aref_*
                else: 
                    use rule * from aref exclude move_starting_reference,process_gtf,tldr_per_sample,get_repeatmasker_raw as aref_*
            else:
                use rule * from aref exclude dorado_seqsummary,pycoQC,process_gtf_tldr,cleanup_updated_ref,repeatmasker,getGtfs as aref_*

            def aref_rally():
                paths = [
                    "aref/A.REF_annotations/A.REF_repeatmasker.complete.gff3.gz.tbi",
                    "aref/A.REF_annotations/refseq.complete.gff3.gz.tbi",
                    "aref/A.REF_annotations/A.REF_repeatmasker_refseq.complete.gtf",
                    "aref/A.REF_annotations/A.REF_repeatmasker_refseq.complete.gff3",
                    "aref/A.REF_annotations/A.REF_repeatmasker.complete.bed",
                    "aref/A.REF_annotations/A.REF_rte_beds/outfile.txt",
                    "aref/A.REF_annotations/A.REF_repeatmasker_refseq.complete.sqlite",
                    "aref/A.REF_annotations/cytobands.bed",
                    "aref/A.REF_annotations/cpg_islands.bed"
                ]
                if config["aref"]["update_ref_with_tldr"]["response"] == "yes":
                    paths.append(expand("aref/qc/{sample_or_ref}/{sample_or_ref}pycoQC.html", sample_or_ref = config["aref"]["samples"]))
                    if config["aref"]["update_ref_with_tldr"]["per_sample"] == "yes":
                        paths.append(expand("aref/{sample_or_ref}_Analysis/tldr_plots/tldr_plots.rds", sample_or_ref = config["aref"]["samples"]))
                        paths.append(expand("aref/{sample_or_ref}_Analysis/tldr_plots/transduction_mapping.rds", sample_or_ref = config["aref"]["samples"]))
                        paths.append(expand("aref/{sample_or_ref}_Analysis/l1element_analysis.outfile", sample_or_ref = config["aref"]["samples"]))
                        paths.append(expand("aref/{sample_or_ref}_annotations/{sample_or_ref}_rte_beds/outfile.txt", sample_or_ref = config["aref"]["samples"]))
                        
                        # paths.append(expand("aref/{sample_or_ref}_Analysis/l1element_analysis.outfile", sample_or_ref = "A.REF"))
                        paths.append(expand("aref/{sample_or_ref}_annotations/{sample_or_ref}_rte_beds/outfile.txt", sample_or_ref = "A.REF"))

                    else:
                        paths.append(expand("aref/{sample_or_ref}_Analysis/tldr_plots/tldr_plots.rds", sample_or_ref = "A.REF"))
                        paths.append(expand("aref/{sample_or_ref}_Analysis/tldr_plots/transduction_mapping.rds", sample_or_ref = "A.REF"))
                        paths.append(expand("aref/{sample_or_ref}_Analysis/l1element_analysis.outfile", sample_or_ref = "A.REF"))
                        paths.append(expand("aref/{sample_or_ref}_annotations/{sample_or_ref}_rte_beds/outfile.txt", sample_or_ref = "A.REF"))


                return list(flatten(paths))
            for e in aref_rally():
                final_input.append(e)
    if pipeline == "ldna":
        module ldna:
            snakefile: "ldna/snakefile"
            config: config
        if config["ldna"]["use_aref_basecalls"] == "yes":
            use rule * from ldna exclude dorado,dorado_seqsummary,pycoQC as ldna_*
        else:
            use rule * from ldna exclude align_to_updated_ref as ldna_*
            tldr_analysis_per_sample = expand("ldna/tldr/{sample}.table.txt", sample = config["ldna"]["samples"])
            pycoQC = expand("ldna/qc/{sample}/{sample}pycoQC.html", sample = config["ldna"]["samples"])
            final_input.append(list(flatten([tldr_analysis_per_sample, pycoQC])))
        dmrs = "ldna/results/tables/dmrs.CG_m.tsv",
        haplotaggedbam = expand("ldna/intermediates/{sample}/alignments/{rate}/{sample}.{type}.{modification_string}.sorted.filtered.haplotagged.bam", rate = config["ldna"]["rate"], type = config["ldna"]["type"], modification_string = config["ldna"]["modification_string"], sample = config["ldna"]["samples"])
        bedmethanalysis = "ldna/outfiles/bedmethylanalysis.txt"
        bedmethanalysis_single_sample = "ldna/outfiles/bedmethylanalysis_single_sample.txt"
        sniffles = expand("ldna/intermediates/{sample}/sniffles/sniffles.vcf", sample = config["ldna"]["samples"])
        clair3 = expand("ldna/intermediates/{sample}/clair3/full_alignment.vcf.gz", sample = config["ldna"]["samples"])
        methylartist = "ldna/results/plots/methylartist/locus/methylartistlocusplot_loci_of_interest.outfile"
        gimme = "ldna/results/gimme/gimme_plots.rds"
        if config["ldna"]["single_condition"] == "yes":
            for e in list(flatten([bedmethanalysis_single_sample,sniffles, clair3, methylartist, haplotaggedbam])):
                final_input.append(e)
        else:
            for e in list(flatten([bedmethanalysis,dmrs, sniffles, clair3, methylartist, haplotaggedbam])):
                final_input.append(e)

    if pipeline == "lrna":
        module lrna:
            snakefile: "lrna/snakefile"
            config: config["lrna"]
        use rule * from lrna as lrna_*
        def lrna_rally():
            deseq = expand("lrna/results/agg/deseq/{alignmenttype}/{counttype}/{contrast}/results_genes.csv", alignmenttype = config["lrna"]["alignmenttypes"], counttype = config["lrna"]["counttypes"], contrast = config["lrna"]["contrasts"])
            enrichment_analysis = expand("lrna/results/agg/enrichment_analysis/{alignmenttype}/{counttype}/outfile.txt", alignmenttype = config["lrna"]["alignmenttypes"], counttype = config["lrna"]["counttypes"])
            enrichment_analysis_repeats = expand("lrna/results/agg/enrichment_analysis_repeats/{alignmenttype}/{counttype}/outfile.txt", alignmenttype = config["lrna"]["alignmenttypes"], counttype = config["lrna"]["counttypes"])
            repeatanalysisplots = expand("lrna/results/agg/repeatanalysis/{alignmenttype}/{counttype}/plots.outfile.txt", alignmenttype = config["lrna"]["alignmenttypes"], counttype = config["lrna"]["counttypes"])
            # genomebrowserplots = expand("lrna/outfiles/genomebrowserplots{alignmenttype}.out", alignmenttype = config["lrna"]["alignmenttypes"])
            qc = [expand("lrna/qc/mycoplasma/mycoplasma{sample}.bam", sample = config["lrna"]["samples"]), "lrna/qc/multiqc_report.html"]
            bw = [expand("lrna/intermediates/{sample}/alignments/genome/{alignmenttype}/{sample}.F.bw", alignmenttype = config["lrna"]["alignmenttypes"], sample = config["lrna"]["samples"]), expand("lrna/intermediates/{sample}/alignments/genome/{alignmenttype}/{sample}.R.bw", alignmenttype = config["lrna"]["alignmenttypes"], sample = config["lrna"]["samples"])],
            m6a = expand("lrna/intermediates/{sample}/m6a/results/data.indiv_proba.csv", sample = config["lrna"]["samples"])
            return list(flatten([m6a, bw, deseq, enrichment_analysis, enrichment_analysis_repeats, qc]))

        for e in lrna_rally():
            final_input.append(e)

    if pipeline == "srna":
        module srna:
            snakefile: "srna/snakefile"
            config: config["srna"]
        if config["srna"]["library_type"] == "PE":
                use rule * from srna exclude fastp_SE,alignSTAR_SE,featurecounts_genes_SE,featurecounts_genesandrtes_SE as srna_*
        else:
                use rule * from srna exclude fastp_PEalignSTAR_PE,featurecounts_genes_PE,featurecounts_genesandrtes_PE as srna_*


        samples = config["srna"]["samples"]
        tecounttypes = config["srna"]["tecounttypes"]
        contrasts = config["srna"]["contrasts"]
        counttypes = config["srna"]["counttypes"]

        def srna_rally():
            deseq = expand("srna/results/agg/deseq_telescope/{tecounttype}/{contrast}/results_genes.csv", tecounttype = config["srna"]["tecounttypes"], contrast = config["srna"]["contrasts"])
            enrichment_analysis = "srna/results/agg/enrichment_analysis/outfile.txt"
            enrichment_analysis_repeats = expand("srna/results/agg/enrichment_analysis_repeats/{tecounttype}/outfile.txt", tecounttype = config["srna"]["tecounttypes"])
            repeatanalysisplots = "srna/results/agg/repeatanalysis_telescope/plots.outfile.txt"
            bigwigs = "srna/results/agg/bigwig_plots/plots.rds"
            qc = [expand("srna/qc/mycoplasma/mycoplasma{sample}.sam", sample = config["srna"]["samples"]), "srna/qc/multiqc/multiqc_report.html"]
            return list(flatten([bigwigs, deseq, enrichment_analysis, enrichment_analysis_repeats, repeatanalysisplots, qc]))
       
        for e in srna_rally():
            final_input.append(e)

# module ldna:
#     snakefile:
#         github("maxfieldk/pipeline", path="workflow/ldna/snakefile", tag="v0.1.0")
#     config:
#         config["ldna"]


rule all:
    input:
        [
            # expand("ldna/qc/{sample}/{sample}pycoQC.html", sample = config["ldna"]["samples"])
            
            final_input            
            ]
    default_target: True


include: "rules.smk"